!
!////////////////////////////////////////////////////////////////////////
!
!      SimpleExtrusion.f90
!      Created: March 28, 2013 9:55 AM 
!      By: David Kopriva  
!
!     Take a quad mesh generated by the SpecMesh2D code and
!     extrude it vertically in the "z" direction to create a
!     3D Hex mesh or rotate it about the x-axis to generate
!     a volume of revolution.
!
!////////////////////////////////////////////////////////////////////////
!
      Module SimpleSweepModule
      USE FTValueDictionaryClass
      USE SMConstants
      USE ProgramGlobals
      USE FTExceptionClass
      USE ReaderExceptions
      USE SharedExceptionManagerModule
      USE HexMeshObjectsModule
      IMPLICIT NONE 
! 
!--------------------------------------------------------------- 
! Define methods to generate a 3D mesh from a 2D one by straight
! line extrusion or simple rotation
!---------------------------------------------------------------
! 
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_ALGORITHM_KEY    = "SimpleExtrusion"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_ROTATION_ALGORITHM_KEY     = "SimpleRotation"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_HEIGHT_KEY       = "ExtrusionHeight"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_SUBDIVISIONS_KEY     = "ExtrusionSubdivisions"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_STARTNAME_KEY        = "ExtrusionStartName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_ENDNAME_KEY          = "ExtrusionEndName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_DIRECTION_KEY        = "ExtrusionDirectionName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_ROTATION_ANGLE_KEY         = "RotationAngleName"
!
!     ========      
      CONTAINS 
!     ========      
!
!////////////////////////////////////////////////////////////////////////
!
      SUBROUTINE ReadSimpleExtrusionBlock( fUnit, dict ) 
!
!        Example block is:
!
!            \begin{SimpleExtrusion}
!               direction          = 1 = x, 2 = y, 3 = z
!               height             = 10.0
!               subdivisions       = 5
!               start surface name = "bottom"
!               end surface name   = "top"
!            \end{SimpleExtrusion}
!
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                  :: fUnit
         CLASS(FTValueDictionary) :: dict
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                                :: ios
         INTEGER                                :: direction
         REAL(KIND=RP)                          :: height
         INTEGER                                :: subdivisions
         CHARACTER(LEN=LINE_LENGTH)             :: inputLine = " ", nameString
         INTEGER      , EXTERNAL                :: GetIntValue
         REAL(KIND=RP), EXTERNAL                :: GetRealValue
         CHARACTER( LEN=LINE_LENGTH ), EXTERNAL :: GetStringValue
         CLASS(FTException), POINTER            :: exception
!
!        ---------
!        Direction
!        ---------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            direction = GetIntValue(inputLine)
            CALL dict % addValueForKey(direction,SIMPLE_SWEEP_DIRECTION_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "direction", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------
!        Height
!        ------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            height = GetRealValue( inputLine )
            CALL dict % addValueForKey(height,SIMPLE_EXTRUSION_HEIGHT_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "height", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------------
!        Subdivisions
!        ------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            subdivisions = GetIntValue( inputLine )
            CALL dict % addValueForKey(subdivisions,SIMPLE_SWEEP_SUBDIVISIONS_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "subdivisions", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        -------------------
!        Bottom surface name
!        -------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_STARTNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "start surface name", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------
!        Top surface name
!        ----------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_ENDNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "end surface name", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 

      END SUBROUTINE ReadSimpleExtrusionBlock
!
!////////////////////////////////////////////////////////////////////////
!
      SUBROUTINE ReadSimpleRotationBlock( fUnit, dict ) 
!
!        Example block is:
!
!            \begin{SimpleRotation}
!               direction               = 1 = x, 2 = y, 3 = z
!               rotation angle factor   = 0.5
!               subdivisions            = 5
!               start surface name      = "bottom"
!               end surface name        = "top"
!            \end{SimpleExtrusion}
!
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                  :: fUnit
         CLASS(FTValueDictionary) :: dict
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                                :: ios
         INTEGER                                :: direction
         INTEGER                                :: subdivisions
         REAL(KIND=RP)                          :: angleFactor
         CHARACTER(LEN=LINE_LENGTH)             :: inputLine = " ", nameString
         INTEGER      , EXTERNAL                :: GetIntValue
         REAL(KIND=RP), EXTERNAL                :: GetRealValue
         CHARACTER( LEN=LINE_LENGTH ), EXTERNAL :: GetStringValue
         CLASS(FTException), POINTER            :: exception
!
!        ---------
!        Direction
!        ---------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            direction = GetIntValue(inputLine)
            CALL dict % addValueForKey(direction,SIMPLE_SWEEP_DIRECTION_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "direction", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------------
!        Angle (Fraction of PI)
!        ----------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            angleFactor = GetRealValue( inputLine )
            CALL dict % addValueForKey(angleFactor,SIMPLE_ROTATION_ANGLE_KEY)
         ELSE 
            exception => ReaderException("Simple rotation read error", "Error reading variable", &
                                       "rotation angle", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------------
!        Subdivisions
!        ------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            subdivisions = GetIntValue( inputLine )
            CALL dict % addValueForKey(subdivisions,SIMPLE_SWEEP_SUBDIVISIONS_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "subdivisions", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        -------------------
!        Bottom surface name
!        -------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_STARTNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "start surface name", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------
!        Top surface name
!        ----------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_ENDNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "end surface name", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 

      END SUBROUTINE ReadSimpleRotationBlock
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE PerformSimpleMeshSweep( project, hex8Mesh, parametersDictionary, algorithmChoice )
         USE MeshProjectClass  
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         TYPE(MeshProject)         :: project
         TYPE( StructuredHexMesh ) :: hex8Mesh
         CLASS(FTValueDictionary)  :: parametersDictionary
!
!        ---------------
!        Local Variables
!        ---------------
!
         CLASS(SMMesh)   , POINTER :: quadMesh
         TYPE(SMElement) , POINTER :: currentQuadElement
         
         INTEGER                           :: numberOfLayers
         INTEGER                           :: numberOf2DNodes, numberOfQuadElements, numberOfEdges
         INTEGER                           :: elementID, nodeID, node2DID, faceID, quadElementID
         INTEGER                           :: i, j, k, l
         INTEGER                           :: eIdLeft, eIDRight, eSideLeft, eSideRight, edgeSideL, edgeSideR
         INTEGER                           :: faceNumber
         INTEGER                           :: N, pMutation
         INTEGER                           :: algorithmChoice
         
         REAL(KIND=RP)                     :: x(3), xTmp(3)
         REAL(KIND=RP)                     :: h, dz, dTheta, theta
         
         TYPE(SMNodePtr)   , DIMENSION(:), ALLOCATABLE :: quadMeshNodes
         CLASS(SMNode)                   , POINTER     :: currentNode, node
         CLASS(SMElement)                , POINTER     :: currentElement
         CLASS(SMElement)                , POINTER     :: e
         CLASS(SMEdge)                   , POINTER     :: currentEdge
         CLASS(FTObject)                 , POINTER     :: obj
         
         CLASS(SMNode)        , POINTER :: node1, node2
         CLASS(SMCurve)       , POINTER :: c
         CLASS(SMChainedCurve), POINTER :: chain
         
         REAL(KIND=RP)               :: tStart, tEnd, t_k, deltaT
         INTEGER                     :: curveId
         CHARACTER(LEN=32)           :: noCurveName(-4:-1) = (/"Right", "Left ", "Front", "Back " /)
         INTEGER                     :: rotMap(3) = [3, 3, 1]
         
!
!        -----------------------------------------------------------------------------
!        dir stores the relative direction of one quad element edge to its neighbor
!        e.g. Side 2 (left) associates with side 1 (right) then the index on the slave
!        runs in the opposite direction. Therefore, dir(2,1) = -1
!        -----------------------------------------------------------------------------
!
         INTEGER, DIMENSION(4,4)  :: dir = RESHAPE((/-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1/),(/4,4/))
!                  
         quadMesh  => project % mesh
         N         =  project % runParams % polynomialOrder
!
!        --------------------------------------------------------
!        Rotate the mesh for extrusion in the requested direction
!        --------------------------------------------------------
!
         pMutation = parametersDictionary % integerValueForKey(key = SIMPLE_SWEEP_DIRECTION_KEY)
         
         IF ( algorithmChoice == SIMPLE_EXTRUSION_ALGORITHM )     THEN
            IF ( pMutation < 3 )     THEN
               CALL quadMesh % rotateMesh(pmutation)
            END IF 
         ELSE ! Rotation about an axis requires 2D mesh to be in a different plane
            IF ( rotMap(pMutation) < 3 )     THEN
               CALL quadMesh % rotateMesh(rotMap(pMutation))
            END IF 
         END IF 
!
!        ---------------------------------------------------------------
!        Make sure that the nodes and elements are consecutively ordered
!        and that the edges refer to the correct elements.
!        ---------------------------------------------------------------
!
         CALL quadMesh % renumberObjects(NODES)
         CALL quadMesh % renumberObjects(ELEMENTS)
         numberOfQuadElements = quadMesh % elements % count()
         CALL quadMesh % buildEdgeList()
!
!        ---------------------------------------------------------------------
!        Allocate memory for the hex mesh. Since the extrusion is 
!        structured in the new direction, the data structures can be accessed
!        as arrays. We also know exactly how many nodes and elements are to be
!        created, so we don't need pointers for most things.
!        ---------------------------------------------------------------------
!
         numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
         CALL NewStructuredHexMeshFromQuadMesh( hex8Mesh, quadMesh, numberOfLayers )
!
!        ----------------------------
!        Gather nodes for easy access
!        ----------------------------
!
         numberOf2DNodes =quadMesh % nodes % count()
         ALLOCATE( quadMeshNodes(numberOf2DNodes) )
         
         CALL quadMesh % nodesIterator % setToStart()
         DO WHILE( .NOT.quadMesh % nodesIterator % isAtEnd())
         
            obj => quadMesh % nodesIterator % object()
            CALL castToSMNode(obj,currentNode)
            node2DID = currentNode % id
            quadMeshNodes(node2DID) % node => currentNode
         
            CALL quadMesh % nodesIterator % moveToNext() 
         END DO 
!
!        ---------------------------------------
!        Generate the new nodes for the hex mesh
!        layer by layer. Order the new node IDs
!        layer by layer, too.
!        ---------------------------------------
!
         IF ( algorithmChoice == SIMPLE_EXTRUSION_ALGORITHM )     THEN
            numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
            h              = parametersDictionary % doublePrecisionValueForKey( SIMPLE_EXTRUSION_HEIGHT_KEY )
            dz             = h/numberofLayers
             
            nodeID = 1
            DO j = 0, numberofLayers
               DO k = 1, numberOf2DNodes
                  hex8Mesh % nodes(k,j) % id = nodeID
                  hex8Mesh % nodes(k,j) % x  = extrudedNodeLocation(baseLocation = quadMeshNodes(k) % node % x, &
                                                                    delta = j*dz, pmutation = pMutation)
                  nodeID = nodeID + 1
               END DO   
            END DO
            
         ELSE
         
            numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
            theta          = PI * parametersDictionary % doublePrecisionValueForKey( SIMPLE_ROTATION_ANGLE_KEY )
            dTheta         = theta/numberofLayers
             
            nodeID = 1
            DO j = 0, numberofLayers
               DO k = 1, numberOf2DNodes
                  hex8Mesh % nodes(k,j) % id     = nodeID
                  hex8Mesh % nodes(k,j) % x = rotatedNodeLocation(baseLocation = quadMeshNodes(k) % node % x, &
                                                                  theta = j*dTheta, pmutation = pMutation) 
                  nodeID = nodeID + 1
               END DO   
            END DO
            
         END IF 
!
!        ---------------------------------
!        Build the elements layer by layer
!        ---------------------------------
!
         elementID = 1
         DO j = 1, numberOfLayers
            quadElementID = 1
            CALL quadMesh % elementsIterator % setToStart()
            DO WHILE( .NOT. quadMesh % elementsIterator % isAtEnd() )
               obj => quadMesh % elementsIterator % object()
               CALL castToSMelement(obj,currentElement)
!
!              -----------------------
!              Set the element nodeIDs
!              -----------------------
!
               DO k = 1, 4
!
!                 -------------
!                 Bottom of hex
!                 -------------
!
                  obj => currentElement % nodes % objectAtIndex(k)
                  CALL cast(obj,node)
                  node2DID = node % id
                  nodeID   = hex8Mesh % nodes(node2DID,j-1) % id
                  hex8Mesh % elements(quadElementID,j) % nodeIDs(k) = nodeID
!
!                 ----------
!                 Top of hex
!                 ----------
!
                  nodeID = hex8Mesh % nodes(node2DID,j) % id
                  hex8Mesh % elements(quadElementID,j) % nodeIDs(k+4) = nodeID
                  
               END DO
               
               hex8Mesh % elements(quadElementID,j) % faceID    = NONE
               hex8Mesh % elements(quadElementID,j) % id        = elementID
               hex8Mesh % elements(quadElementID,j) % bFaceFlag = OFF
               hex8Mesh % elements(quadElementID,j) % bFaceName = "---"
               quadElementID                                 = quadElementID + 1
               elementID                                     = elementID + 1
               
               CALL quadMesh % elementsIterator % moveToNext()
            END DO 
         END DO 
!
!        ----------------------------------
!        Construct the faces from the edges
!        ----------------------------------
!         
         DO j = 1, numberOfLayers
            faceID = 1
            
            CALL quadMesh % edgesIterator % setToStart()
            DO WHILE( .NOT. quadMesh % edgesIterator % isAtEnd() )
               obj => quadMesh % edgesIterator % object()
               CALL cast(obj, currentEdge)
               
               hex8Mesh % faces(faceID,j) % id   = faceID
               hex8Mesh % faces(faceID,j) % edge => currentEdge
               CALL currentEdge % retain()
!
!              --------------------
!              Set the left element
!              --------------------
!
               e             => currentEdge % elements(1) % element
               quadElementID = e % id
               eIdLeft       = hex8Mesh % elements(quadElementID,j) % id
               edgeSideL     = currentEdge % elementSide(1)
               
               hex8Mesh % faces(faceID,j) % elementIDs(1) = eIdLeft
               faceNumber                                 = hexFaceForQuadEdge(edgeSideL)
               hex8Mesh % faces(faceID,j) % faceNumber(1) = faceNumber
!
!              -------------------------
!              Refer back to the element
!              -------------------------
!
               hex8Mesh % elements(quadElementID,j) % faceID(hex8Mesh % faces(faceID,j) % faceNumber(1)) = faceID
!
!              -------------
!              Add the nodes
!              -------------
!
               DO k = 1, 4
                  hex8Mesh % faces(faceID,j) % nodeIDs(k) = &
                  hex8Mesh % elements(quadElementID,j) % nodeIDs(localFaceNode(k,hex8Mesh % faces(faceID,j) % faceNumber(1)))
               END DO  
!
!              ---------------------
!              Set the right element
!              ---------------------
!
               e  => currentEdge % elements(2) % element
               IF ( ASSOCIATED( e ) )     THEN
                  quadElementID = e % id
                  eIdRight      = hex8Mesh % elements(quadElementID,j) % id
                  edgeSideR     = currentEdge % elementSide(2)
                 
                  hex8Mesh % faces(faceID,j) % elementIDs(2) = eIdRight
                  hex8Mesh % faces(faceID,j) % faceNumber(2) = hexFaceForQuadEdge(edgeSideR)
                  hex8Mesh % faces(faceID,j) % inc           = [dir(edgeSideL,edgeSideR),1]
                  
                  hex8Mesh % elements(quadElementID,j) % faceID(hex8Mesh % faces(faceID,j) % faceNumber(2)) = faceID

               ELSE
                  hex8Mesh % faces(faceID,j) % elementIDs(2) = NONE
                  hex8Mesh % faces(faceID,j) % faceNumber(2) = NONE
                  hex8Mesh % faces(faceID,j) % inc           = 0
               END IF
!
!              ----------------------------------
!              Generate boundary face information
!              ----------------------------------
!
               IF ( .NOT.ASSOCIATED(e) )     THEN ! This is a boundary face
                  node1 => currentEdge % nodes(1) % node
                  node2 => currentEdge % nodes(2) % node
!
!                 ---------------------------------------------------------------------------
!                 See if this edge is on a boundary. One of the two nodes should be
!                 a ROW_SIDE, and that one is on a curve rather than the joint of two curves.
!                 The edge could be on an outer box, in which case it is a straight line, but
!                 still needs boundary name information
!                 ---------------------------------------------------------------------------
!
                  IF( IsOnBoundaryCurve(node1) .AND. IsOnBoundaryCurve(node2) )     THEN
!
!                    -----------------------------------------------------------
!                    Mark as on a boundary curve needing interpolant information
!                    -----------------------------------------------------------
!
                     hex8Mesh % elements(quadElementID,j) % bFaceFlag(faceNumber) = ON
                     
                     IF( node1 % nodeType == ROW_SIDE )     THEN
                        curveID = node1 % bCurveID
                        c => project % model % curveWithID(curveId, chain)
                     ELSE
                        curveID = node2 % bCurveID
                        c => project % model % curveWithID(curveId, chain)
                     END IF
                     
                     hex8Mesh % elements(quadElementID,j) % bFaceName(faceNumber) = c % curveName()
                     tStart = node1 % gWhereOnBoundary
                     tEnd   = node2 % gWhereOnBoundary
!
!                    ------------------------------
!                    Compute the interpolant points
!                    ------------------------------
!
                     deltaT = tEnd - tStart
                     IF( deltaT > maxParameterChange )     THEN !Crossing over the start
                        deltaT = deltaT - 1.0_RP
                     ELSE IF (deltaT < -maxParameterChange ) THEN
                        deltaT = 1.0_RP + deltaT
                     END IF
                    
                     ALLOCATE(hex8Mesh % faces(faceID,j) % x(3,0:N,0:N,6))
                     DO k = 0, N 
                    
                        t_k = tStart + deltaT*(1.0_RP - COS(k*PI/N))/2.0_RP
                        IF( t_k > 1.0_RP )     THEN
                           t_k = t_k - 1.0_RP
                        ELSE IF( t_k < 0.0_RP )     THEN
                           t_k = t_k + 1.0_RP
                        END IF
                        
                        x = chain % positionAt(t_k)
                        DO l = 0, N
                           t_k =  (j-1)*dz + dz*(1.0_RP - COS(l*PI/N))/2.0_RP
                           xTmp = [x(1),x(2),t_k]
                           IF(pMutation<3) xTmp = CSHIFT(xTmp, SHIFT = -pmutation)
                           hex8Mesh % faces(faceID,j) % x(:,k,l,faceNumber) = xTmp 
                        END DO  
                        
                      END DO

                  ELSE IF ( IsOnOuterBox(node1) .AND. IsOnOuterBox(node2) )     THEN
!
!                    --------------------------------------------------------------
!                    Only mark the boundary names for output, no interpolant needed
!                    --------------------------------------------------------------
!
                     IF( node1 % nodeType == CORNER_NODE )     THEN
                        hex8Mesh % elements(quadElementID,j) % bFaceName(faceNumber) = noCurveName(node2 % bCurveID)
                     ELSE
                        hex8Mesh % elements(quadElementID,j) % bFaceName(faceNumber) = noCurveName(node1 % bCurveID)
                     END IF
                     
                  END IF

               END IF 
!              
               faceID = faceID + 1
            CALL quadMesh % edgesIterator % moveToNext()     
            END DO 
         END DO
!
!        ----------------------------
!        Construct the bottom and top 
!        faces from the layers
!        ----------------------------
!
         DO j = 0, numberOfLayers
            
            IF ( j == 0 )     THEN
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft    = hex8Mesh % elements(quadElementID,1) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 3
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,1) % nodeIDs(localFaceNode(k,3))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 0
!                  
               END DO
               
            ELSE IF (j == numberOfLayers)     THEN
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft    = hex8Mesh % elements(quadElementID,numberOfLayers) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 5
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,numberOfLayers) % nodeIDs(localFaceNode(k,5))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 0
!                  
               END DO
               
            ELSE
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft = hex8Mesh % elements(quadElementID,j) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 5
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,numberOfLayers) % nodeIDs(localFaceNode(k,5))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  eIdRight = hex8Mesh % elements(quadElementID,j+1) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = eIdRight
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = 3
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 1
!                  
               END DO
            END IF 

         END DO  
!

      END SUBROUTINE PerformSimpleMeshSweep
!
!//////////////////////////////////////////////////////////////////////// 
! 
      FUNCTION extrudedNodeLocation(baseLocation,delta,pmutation)  RESULT(x)
         IMPLICIT NONE  
         REAL(KIND=RP) :: baseLocation(3), delta
         INTEGER       :: pmutation
         REAL(KIND=RP) :: x(3)
               
         x              = baseLocation
         x(pmutation)   = delta 
      END FUNCTION extrudedNodeLocation
!
!//////////////////////////////////////////////////////////////////////// 
! 
      FUNCTION rotatedNodeLocation(baseLocation,theta,pmutation)  RESULT(x)
         IMPLICIT NONE  
         REAL(KIND=RP) :: baseLocation(3), theta
         INTEGER       :: pmutation
         REAL(KIND=RP) :: x(3)
         REAL(KIND=RP) :: r
               
         x              = baseLocation
         SELECT CASE ( pmutation )
            CASE( 1 ) ! rotation about x-Axis
               r    = baseLocation(2)
               x(2) = r*COS(theta)
               x(3) = r*SIN(theta)
            CASE (2)  ! rotation about y-Axix
               r    = baseLocation(1)
               x(1) = r*COS(theta)
               x(3) = r*SIN(theta)
            CASE (3)  ! rotation about z-Axis
               r    = baseLocation(2)
               x(2) = r*COS(theta)
               x(1) = r*SIN(theta)
            CASE DEFAULT 
         END SELECT 
         
      END FUNCTION rotatedNodeLocation

      END Module SimpleSweepModule 