!
!////////////////////////////////////////////////////////////////////////
!
!      SimpleExtrusion.f90
!      Created: March 28, 2013 9:55 AM 
!      By: David Kopriva  
!
!     Take a quad mesh generated by the SpecMesh2D code and
!     extrude it vertically in the "z" direction to create a
!     3D Hex mesh.
!
!////////////////////////////////////////////////////////////////////////
!
      Module SimpleExtrusionModule
      USE FTValueDictionaryClass
      USE SMConstants
      USE ProgramGlobals
      USE FTExceptionClass
      USE ReaderExceptions
      USE SharedExceptionManagerModule
      USE HexMeshObjectsModule
      IMPLICIT NONE 
! 
!--------------------------------------------------------------- 
! Define methods to generate a 3D mesh from a 2D one by straight
! line extrusion 
!---------------------------------------------------------------
! 
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_ALGORITHM_KEY    = "SimpleExtrusion"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_HEIGHT_KEY       = "ExtrusionHeight"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_SUBDIVISIONS_KEY = "ExtrusionSubdivisions"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_STARTNAME_KEY    = "ExtrusionStartName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_ENDNAME_KEY      = "ExtrusionEndName"
!
!     ========      
      CONTAINS 
!     ========      
!
!////////////////////////////////////////////////////////////////////////
!
      SUBROUTINE ReadSimpleExtrusionBlock( fUnit, dict ) 
!
!        Example block is:
!
!            \begin{SimpleExtrusion}
!               height             = 10.0
!               subdivisions       = 5
!               start surface name = "bottom"
!               end surface name   = "top"
!            \end{SimpleExtrusion}
!
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                  :: fUnit
         CLASS(FTValueDictionary) :: dict
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                                :: ios
         REAL(KIND=RP)                          :: height
         INTEGER                                :: subdivisions
         CHARACTER(LEN=LINE_LENGTH)             :: inputLine = " ", nameString
         INTEGER      , EXTERNAL                :: GetIntValue
         REAL(KIND=RP), EXTERNAL                :: GetRealValue
         CHARACTER( LEN=LINE_LENGTH ), EXTERNAL :: GetStringValue
         CLASS(FTException), POINTER            :: exception
!
!        ------
!        Height
!        ------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            height = GetRealValue( inputLine )
            CALL dict % addValueForKey(height,SIMPLE_EXTRUSION_HEIGHT_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "height", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------------
!        Subdivisions
!        ------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            subdivisions = GetIntValue( inputLine )
            CALL dict%addValueForKey(subdivisions,SIMPLE_EXTRUSION_SUBDIVISIONS_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "subdivisions", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        -------------------
!        Bottom surface name
!        -------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict%addValueForKey(nameString,SIMPLE_EXTRUSION_STARTNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "start surface name", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------
!        Top surface name
!        ----------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict%addValueForKey(nameString,SIMPLE_EXTRUSION_ENDNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "end surface name", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 

      END SUBROUTINE ReadSimpleExtrusionBlock
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE PerformSimpleMeshExtrusion( project, hex8Mesh, parametersDictionary )
         USE MeshProjectClass  
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         TYPE(MeshProject)         :: project
         TYPE( StructuredHexMesh ) :: hex8Mesh
         CLASS(FTValueDictionary)  :: parametersDictionary
!
!        ---------------
!        Local Variables
!        ---------------
!
         TYPE(DKUnstructuredMesh), POINTER :: quadMesh
         TYPE(DKElement)         , POINTER :: currentQuadElement
         
         INTEGER                           :: numberOfLayers
         INTEGER                           :: numberOf2DNodes, numberOfQuadElements, numberOfEdges
         INTEGER                           :: elementID, nodeID, node2DID, faceID, quadElementID
         INTEGER                           :: i, j, k, l
         INTEGER                           :: eIdLeft, eIDRight, eSideLeft, eSideRight, edgeSideL, edgeSideR
         INTEGER                           :: faceNumber
         INTEGER                           :: N
         
         REAL(KIND=RP)                     :: x(3), x2(2)
         REAL(KIND=RP)                     :: h, dz
         
         TYPE(DKNodePtr)   , DIMENSION(:), ALLOCATABLE :: quadMeshNodes
         TYPE(DKNode)                    , POINTER     :: currentNode
         TYPE(DKElement)                 , POINTER     :: currentElement
         TYPE(DKElement)                 , POINTER     :: e
         TYPE(DKEdge)                    , POINTER     :: currentEdge
         
         TYPE(DKNode)      , POINTER :: node1, node2
         TYPE(Curve)       , POINTER :: c
         TYPE(ChainedCurve), POINTER :: chain
         
         REAL(KIND=RP)               :: tStart, tEnd, t_k, deltaT
         INTEGER                     :: curveId
         CHARACTER(LEN=32)           :: noCurveName(-4:-1) = (/"Right", "Left ", "Front", "Back " /)
!
!        -----------------------------------------------------------------------------
!        dir stores the relative direction of one quad element edge to its neighbor
!        e.g. Side 2 (left) associates with side 1 (right) then the index on the slave
!        runs in the opposite direction. Therefore, dir(2,1) = -1
!        -----------------------------------------------------------------------------
!
         INTEGER, DIMENSION(4,4)  :: dir = RESHAPE((/-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1/),(/4,4/))
         
         quadMesh  => project%mesh
         N         =  project % runParams % polynomialOrder
!
!        ---------------------------------------------------------------
!        Make sure that the nodes and elements are consecutively ordered
!        and that the edges refer to the correct elements.
!        ---------------------------------------------------------------
!
         CALL NumberTheNodesInList   ( quadMesh%nodes )
         CALL NumberTheElementsInList( quadMesh%elements )
         CALL DestructEdgeList       ( quadMesh%edges )
         numberOfQuadElements          = ElementListCount( quadMesh%elements )
         quadMesh%edges => newEdgeList()
         CALL BuildEdgeList( quadMesh )
!
!        ---------------------------------------------------------------------
!        Allocate memory for the hex mesh. Since the extrusion is 
!        structured in the new direction, the data structures can be accessed
!        as arrays. We also know exactly how many nodes and elements are to be
!        created, so we don't need pointers for most things.
!        ---------------------------------------------------------------------
!
         numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_EXTRUSION_SUBDIVISIONS_KEY )
         CALL NewStructuredHexMeshFromQuadMesh( hex8Mesh, quadMesh, numberOfLayers )
!
!        ----------------------------
!        Gather nodes for easy access
!        ----------------------------
!
         numberOf2DNodes = NodeListCount(quadMesh%nodes)
         ALLOCATE( quadMeshNodes(numberOf2DNodes) )
         
         CALL NodeListIteratorInit( quadMesh % nodes )
         DO WHILE ( .NOT.NodeListIteratorDone( quadMesh % nodes ) )
            currentNode => NodeListCurrent( quadMesh % nodes )
            node2DID = currentNode % id
            quadMeshNodes(node2DID)%node => currentNode
            CALL StepNodeListIterator( quadMesh % nodes )
         END DO
!
!        ---------------------------------------
!        Generate the new nodes for the hex mesh
!        layer by layer. Order the new node IDs
!        layer by layer, too.
!        ---------------------------------------
!
         numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_EXTRUSION_SUBDIVISIONS_KEY )
         h              = parametersDictionary % doublePrecisionValueForKey( SIMPLE_EXTRUSION_HEIGHT_KEY )
         dz             = h/numberofLayers
          
         nodeID = 1
         DO j = 0, numberofLayers
            DO k = 1, numberOf2DNodes
               x2 = quadMeshNodes(k)% node % x
               hex8Mesh%nodes(k,j) % id     = nodeID
               hex8Mesh%nodes(k,j) % x(1:2) = x2
               hex8Mesh%nodes(k,j) % x(3)   = j*dz
               nodeID = nodeID + 1
            END DO   
         END DO
!
!        ---------------------------------
!        Build the elements layer by layer
!        ---------------------------------
!
         elementID = 1
         DO j = 1, numberOfLayers
            quadElementID = 1
            CALL ElementListIteratorInit( quadMesh % elements )
            DO WHILE ( .NOT.ElementListIteratorDone( quadMesh % elements ) )
               currentElement => ElementListCurrent( quadMesh % elements )
!
!              -----------------------
!              Set the element nodeIDs
!              -----------------------
!
               DO k = 1, 4
!
!                 -------------
!                 Bottom of hex
!                 -------------
!
                  node2DID = currentElement % nodes(k) %node % id
                  nodeID   = hex8Mesh%nodes(node2DID,j-1) % id
                  hex8Mesh%elements(quadElementID,j)%nodeIDs(k) = nodeID
!
!                 ----------
!                 Top of hex
!                 ----------
!
                  nodeID = hex8Mesh%nodes(node2DID,j) % id
                  hex8Mesh%elements(quadElementID,j)%nodeIDs(k+4) = nodeID
                  
               END DO
               
               hex8Mesh % elements(quadElementID,j) % faceID    = NONE
               hex8Mesh % elements(quadElementID,j) % id        = elementID
               hex8Mesh % elements(quadElementID,j) % bFaceFlag = OFF
               hex8Mesh % elements(quadElementID,j) % bFaceName = "---"
               quadElementID                                 = quadElementID + 1
               elementID                                     = elementID + 1
               CALL StepElementListIterator( quadMesh % elements )
            END DO
         END DO
!
!        ----------------------------------
!        Construct the faces from the edges
!        ----------------------------------
!         
         DO j = 1, numberOfLayers
            faceID = 1
            
            CALL EdgeListIteratorInit( quadMesh % edges )
            DO WHILE ( .NOT.EdgeListIteratorDone( quadMesh % edges ) )
               currentEdge => EdgeListCurrent( quadMesh % edges )
               
               hex8Mesh % faces(faceID,j) % id        = faceID
               hex8Mesh % faces(faceID,j) % edge      => currentEdge
               CALL RetainEdge(currentEdge)
!
!              --------------------
!              Set the left element
!              --------------------
!
               e             => currentEdge % elements(1) % element
               quadElementID = e % id
               eIdLeft       = hex8Mesh % elements(quadElementID,j) % id
               edgeSideL     = currentEdge % elementSide(1)
               
               hex8Mesh % faces(faceID,j) % elementIDs(1) = eIdLeft
               faceNumber                                 = hexFaceForQuadEdge(edgeSideL)
               hex8Mesh % faces(faceID,j) % faceNumber(1) = faceNumber
!
!              -------------------------
!              Refer back to the element
!              -------------------------
!
               hex8Mesh%elements(quadElementID,j) % faceID(hex8Mesh % faces(faceID,j) % faceNumber(1)) = faceID
!
!              -------------
!              Add the nodes
!              -------------
!
               DO k = 1, 4
                  hex8Mesh % faces(faceID,j) % nodeIDs(k) = &
                  hex8Mesh % elements(quadElementID,j) % nodeIDs(localFaceNode(k,hex8Mesh % faces(faceID,j) % faceNumber(1)))
               END DO  
!
!              ---------------------
!              Set the right element
!              ---------------------
!
               e  => currentEdge % elements(2) % element
               IF ( ASSOCIATED( e ) )     THEN
                  quadElementID = e % id
                  eIdRight      = hex8Mesh % elements(quadElementID,j) % id
                  edgeSideR     = currentEdge % elementSide(2)
                 
                  hex8Mesh % faces(faceID,j) % elementIDs(2) = eIdRight
                  hex8Mesh % faces(faceID,j) % faceNumber(2) = hexFaceForQuadEdge(edgeSideR)
                  hex8Mesh % faces(faceID,j) % inc           = [dir(edgeSideL,edgeSideR),1]
                  
                  hex8Mesh%elements(quadElementID,j) % faceID(hex8Mesh % faces(faceID,j) % faceNumber(2)) = faceID

               ELSE
                  hex8Mesh % faces(faceID,j) % elementIDs(2) = NONE
                  hex8Mesh % faces(faceID,j) % faceNumber(2) = NONE
                  hex8Mesh % faces(faceID,j) % inc           = 0
               END IF
!
!              ----------------------------------
!              Generate boundary face information
!              ----------------------------------
!
               IF ( .NOT.ASSOCIATED(e) )     THEN ! This is a boundary face
                  node1 => currentEdge % nodes(1) % node
                  node2 => currentEdge % nodes(2) % node
!
!                 ---------------------------------------------------------------------------
!                 See if this edge is on a boundary. One of the two nodes should be
!                 a ROW_SIDE, and that one is on a curve rather than the joint of two curves.
!                 The edge could be on an outer box, in which case it is a straight line, but
!                 still needs boundary name information
!                 ---------------------------------------------------------------------------
!
                  IF( IsOnBoundaryCurve(node1) .AND. IsOnBoundaryCurve(node2) )     THEN
!
!                    -----------------------------------------------------------
!                    Mark as on a boundary curve needing interpolant information
!                    -----------------------------------------------------------
!
                     hex8Mesh % elements(quadElementID,j) % bFaceFlag(faceNumber) = ON
                     
                     IF( node1%nodeType == ROW_SIDE )     THEN
                        curveID = node1%bCurveID
                        c       => CurveWithID_InModel_( node1%bCurveID, project % model, chain )
                     ELSE
                        curveID = node2%bCurveID
                        c       => CurveWithID_InModel_( node2%bCurveID, project % model, chain )
                     END IF
                     
                     hex8Mesh % elements(quadElementID,j) % bFaceName(faceNumber) = c%curveName
                     tStart = node1%gWhereOnBoundary
                     tEnd   = node2%gWhereOnBoundary
!
!                    ------------------------------
!                    Compute the interpolant points
!                    ------------------------------
!
                     deltaT = tEnd - tStart
                     IF( deltaT > maxParameterChange )     THEN !Crossing over the start
                        deltaT = deltaT - 1.0_RP
                     ELSE IF (deltaT < -maxParameterChange ) THEN
                        deltaT = 1.0_RP + deltaT
                     END IF
                    
                     ALLOCATE(hex8Mesh % faces(faceID,j) % x(3,0:N,0:N,6))
                     DO k = 0, N 
                    
                        t_k = tStart + deltaT*(1.0_RP - COS(k*PI/N))/2.0_RP
                        IF( t_k > 1.0_RP )     THEN
                           t_k = t_k - 1.0_RP
                        ELSE IF( t_k < 0.0_RP )     THEN
                           t_k = t_k + 1.0_RP
                        END IF
                        
                        x2 = PositionAt_( chain, t_k )
                        DO l = 0, N
                           t_k =  (j-1)*dz + dz*(1.0_RP - COS(l*PI/N))/2.0_RP
                           hex8Mesh % faces(faceID,j) % x(:,k,l,faceNumber) = [x2(1),x2(2),t_k]
                        END DO  
                        
                      END DO

                  ELSE IF ( IsOnOuterBox(node1) .AND. IsOnOuterBox(node2) )     THEN
!
!                    --------------------------------------------------------------
!                    Only mark the boundary names for output, no interpolant needed
!                    --------------------------------------------------------------
!
                     IF( node1%nodeType == CORNER_NODE )     THEN
                        hex8Mesh % elements(quadElementID,j) % bFaceName(faceNumber) = noCurveName(node2%bCurveID)
                     ELSE
                        hex8Mesh % elements(quadElementID,j) % bFaceName(faceNumber) = noCurveName(node1%bCurveID)
                     END IF
                     
                  END IF

               END IF 
!              
               faceID = faceID + 1
               CALL StepEdgeListIterator( quadMesh % edges )
               
            END DO
         END DO
!
!        ----------------------------
!        Construct the bottom and top 
!        faces from the layers
!        ----------------------------
!
         DO j = 0, numberOfLayers
            
            IF ( j == 0 )     THEN
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft    = hex8Mesh % elements(quadElementID,1) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 3
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,1) % nodeIDs(localFaceNode(k,3))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 0
!                  
               END DO
               
            ELSE IF (j == numberOfLayers)     THEN
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft    = hex8Mesh % elements(quadElementID,numberOfLayers) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 5
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,numberOfLayers) % nodeIDs(localFaceNode(k,5))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 0
!                  
               END DO
               
            ELSE
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft = hex8Mesh % elements(quadElementID,j) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 5
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,numberOfLayers) % nodeIDs(localFaceNode(k,5))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  eIdRight = hex8Mesh % elements(quadElementID,j+1) % id
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = eIdRight
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = 3
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 1
!                  
               END DO
            END IF 
            
         END DO  
!

      END SUBROUTINE PerformSimpleMeshExtrusion

      END Module SimpleExtrusionModule 